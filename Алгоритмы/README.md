# Longest Palindromic Substring
Данная задача располагается в файле [Longest Palindromic Substring.py](https://github.com/roge111/Algorithms-and-data-structures/blob/main/Алгоритмы/Longest%20Palindromic%20Substring.py)

Текущая задача решается в рамках подготовки к собесеодования в Яндекс. Задача среднего уровня сложности. 

На вход приходит строка s. Внутри строки s надо найти подстраку максимальной длины, которая является палиндромом. 

### Алгоритм
--
Для решения используем динамическое программирование. Цель — хранить True или False для `i, j`, где i — это индекс слева подстроки, а j — справа. Такой алгоритм позволяет нам не использовать срезы. И если первый и последний символ подстроки равны и подстрока с i+1 до j-1 тоже полиндром, то текущая подстрока — полиндром, и выставляем True для i, j.

### Решение
--

```
class Solution(object):
    def longestPalindrome(self, s):
        dp = [[False] *len(s) for _ in range(len(s))]
        start = 0
        max_len = 0
        for i in range(len(s)):
            start = i
            max_len = 1
            dp[i][i] = True
        for i in range(len(s)-1):
            if s[i] == s[i+1]:
                dp[i][i+1] = True
                start = i
                max_len = 2
            
        for l in range(3, len(s)+1):
            for i in range(len(s) - l + 1):
                j = i + l -1
                if s[i] == s[j] and dp[i+1][j-1]:
                    dp[i][j] = True
                    if l > max_len:
                        max_len = l
                        start = i
        return s[start:start+max_len]
```
Мы заполняем массив dp False. Выходит у нас массив длиной `len(s)` из подмассивов длиной `len(s)`, заполненных `False`, где по координатам i и j можно понять, является подстрока от i до j полиндромом. 

Первый цикл заполняет все первые элементы всех подмассивов True, так как все элементы длины 1 — полиндромы.

Второй цикл берет уже подстроки длиной 2 и проверяет, равны ли два символа друг другу, и выставляет True в случае истины по координатам `i, i+1`. 
Далее третий цикл перебирает различные длины от 3 до `len(s)` включительно. `j = i + l - 1`. Если первый и последний элементы равны, а подстрока между ними — это полиндром, то выставляем True в dp по координатам `i, j`. Сравниваем длины. Если новая длина больше имеющейся, то обновляем максимальную длину и точку старта подстроки с максимальной длиной.

Возвращаем строку от `start` до `start + max_len`. 



# Unique Paths

На сетке m x n находится робот. Изначально робот находится в верхнем левом углу (то есть в `grid[0][0]`). Робот пытается переместиться в нижний правый угол (то есть в `grid[m - 1][n - 1]`). В любой момент времени робот может перемещаться только вниз или вправо.

Учитывая два целых числа `m` и `n`, верните количество возможных уникальных путей, по которым робот может добраться до правого нижнего угла.

Тестовые примеры генерируются таким образом, чтобы ответ был меньше или равен `2 * 109`.

Пример:

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

`Ввод`: m = 3, n = 2
`Вывод`: 28

# Best Time to Buy and Sell Stock
Вам дан массив `prices` с ценами `prices[i]` на акции в день `i` .

Вы хотите максимизировать свою прибыль, выбрав один день для покупки акций и другой день в будущем для их продажи.

Верните максимальную прибыль, которую вы можете получить от этой сделки. Если вы не можете получить никакой прибыли, верните 0.

Пример:

  `Входные данные`: цены = [7,1,5,3,6,4]
  `Выходные данные`: 5

# Stairs

Вы поднимаетесь по лестнице. Чтобы добраться до верха, нужно n шагов.

Каждый раз вы можете либо подняться по 1 ступеням, либо спуститься по 2 ступеням. Сколькими разными способами вы можете подняться на вершину?

Пример:

`Ввод`: n = 2

`Вывод`: 2

# Pascal`s Triangle


Учитывая целое число `numRows`, верните первые `num` строк треугольника Паскаля.

В треугольнике Паскаля каждое число является суммой двух чисел, расположенных непосредственно над ним, как показано на рисунке:

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

Пример:

`Ввод`: numRows = 5

`Вывод`: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]


# Basic Calculate

Учитывая строку ``s, представляющую допустимое выражение, реализуйте базовый калькулятор для его вычисления и верните _результат вычисления_.

Примечание: вам нельзя использовать встроенные функции, которые вычисляют строки как математические выражения, например `eval()`.

Пример:

`Ввод`: s = "(1+(4+5+2)-3)+(6+8)"
`Вывод`: 23

Ограничения:
  - 1 <= s.length <= 3 * 105
  
  - s состоит из цифр, '+', '-' '(', ')' и ' '.
  
  - s представляет собой допустимое выражение.
  
  - '+' Не используется в качестве унарной операции (то есть "+1" и "+(2 + 3)" недопустимы).
  
  - '-' может использоваться как унарная операция (т. е. "-1" и "-(2 + 3)" допустимы).
  
  - Во входных данных не будет двух последовательных операторов.
  
  - Каждое число и текущие вычисления будут помещаться в 32-битное целое число со знаком.
  
